# 基本
- 『.git』フォルダをうっかり削除すると、そのディレクトリはGit管理されていない状態になる。消去禁止。
- 既存のプロジェクトにも、同様に `git init` を使えばGitで管理を開始可能。
# よく使用する一連の流れ
## 初めて、
GitHubで新規リポジトリを作成して、URLをメモ  
VScode等のターミナルで
```
git init
git add .
git commit -m "first commit"
```
```
git remote add origin https://github.com/username/リポジトリ名
```
```
git branch -M main
git push -u origin main

```

## 2回目以降（通常）
```
git add .
```
```
git commit -m "fix: カメラ機能を追加等" 

```
```
git push
```
## 2回目以降パターン
リモートの変更を取り込んでから push（推奨）
```
git pull origin main --rebase
git push origin main

```
「GitHub 側の変更は不要で、ローカルの内容で完全に上書きしたい」場合のみ：チームでしている時は、避ける
```
git push origin main --force
```
# 詳細説明
## ステージング（git add）
変更されたファイルを「次のコミット対象として一時的に登録」する操作
- なぜステージングが必要なの？
  - ステージングを行うことで、どの変更を記録するか細かく選べるようになります。作業中に複数のファイルを編集していても、必要な変更だけを履歴に残すことができます。
### 全てのファイルをまとめてステージング
```
git add .
```
### ファイル指定でステージング
```
git add ファイル名 : ファイルをステージに追加
```
## コミット（git commit）
ステージングされた内容を「履歴として保存」する操作
```
git commit -m "メッセージ" : ステージされた内容を履歴に保存
```
## ステージングを取り消す
```
git restore --staged ファイル名
```
## 変更内容を把握
### 変更したファイルを把握：git status
```
git status
```
- どのファイルを add していて、どのファイルがまだ add されていないかも確認可能
  - add されたファイルが緑色、まだ add されていないファイルが赤色で表示
### 変更したコード内容まで把握：git diff
```
git diff
```
変更前のコードが赤色、変更後のコードが緑色で表示
## 履歴：git log
出力の上にあるほど新しい
```
git log
```
変更内容まで見る
```
git log -p
```
表示内容が多い時は右の図のように特殊な表示モードになる。
上下キーを使うと表示範囲を変えられて、Qキーを押すことで終了。
# 未整理

origin と upstream の違い
Gitでは、リモートリポジトリに名前（リモート名）を付けて管理します。
origin: 自分が クローン元 にしたリモートリポジトリ。通常は自分が更新する先（push先）です。
upstream: オープンソースなどで 元となる開発元のリポジトリ。フォークしたリポジトリの親となります。
```
git remote -v
```
フォーク元のリポジトリを追跡したい場合は、次のように upstream を追加します。
```
git remote add upstream https://github.com/original-author/project.git
```
upstream の変更を取り込むときは、次のようなコマンドを使います
```
git fetch upstream
git merge upstream/main
```
origin や upstream は単なる「名前」です。git remote add <name> <URL> で自由に設定できます。
チーム開発やオープンソース開発では、origin と upstream を明確に使い分けることで混乱を防げます。


GitHubが表示する「リモート設定用のコマンド」を使って、ローカルリポジトリと接続します。
```
git remote add origin https://github.com/あなたのユーザー名/my-first-repo.git
```
初回コミット
ローカルにすでにファイルとコミットが存在する場合。
```
git push -u origin main
```

remote already exists というエラーが出た場合、すでにリモートが追加されている可能性があります。
git remote set-url origin <URL> を使ってURLを更新できます。
GitHubのリポジトリを初期化済み（READMEなどあり）の場合、git pull してから push する必要があります。



コマンド
役割
git clone
GitHubからプロジェクトをコピーしてくる
git push
ローカルの変更をGitHubにアップロードする
git pull
GitHubから最新の変更を取り込む
```
git clone https://github.com/あなたのユーザー名/my-first-repo.git
```
成功すると、新しいフォルダ my-first-repo が作成され、その中にGitリポジトリが複製されます。
出力結果
Cloning into 'my-first-repo'...
remote: Enumerating objects: 3, done.
remote: Total 3 (delta 0), reused 0 (delta 0), pack-reused 3
Unpacking objects: 100% (3/3), done.
2. クローンしたフォルダに移動してファイルを編集
クローンしたプロジェクトに移動して、実際にファイルを編集してみましょう。
terminal.sh
cd my-first-repo
echo "GitHub連携テスト" > test.txt
3. ファイルを追加してコミットする
編集したファイルをGitに登録し、変更履歴として記録します。
terminal.sh
git add test.txt
git commit -m "Add test.txt for GitHub push test"
出力結果
[main xxxxxxx] Add test.txt for GitHub push test
 1 file changed, 1 insertion(+)
 create mode 100644 test.txt
4. GitHubに変更をアップロードする（push）
ここでリモートリポジトリにアップロード（push）を行います。
初回はユーザー認証（PATなど）が求められます。
terminal.sh
git push origin main
出力結果
Enumerating objects: 5, done.
Counting objects: 100% (5/5), done.
Compressing objects: 100% (2/2), done.
Writing objects: 100% (3/3), done.
To https://github.com/yourname/my-first-repo.git
 * [new branch]      main -> main
5. GitHub上の内容をローカルに取り込む（pull）
他の人が変更を加えた場合や、別PCで編集した内容をローカルに反映したいときは pull を使います。
terminal.sh
git pull origin main
出力結果
Already up to date.
補足
git push 時に「authentication failed」などのエラーが出た場合は、PAT（パーソナルアクセストークン）を使用して認証してください。
pull でコンフリクト（衝突）が起きた場合は、どちらの変更を優先するかを選択して手動で修正する必要があります。


feature/〇〇 という形式のブランチ名は、「新しい機能（feature）を追加するための作業ブランチ」を意味します。
たとえば、ログイン画面を作る場合は feature/login-ui という名前でブランチを作ると、何の作業をするブランチかがひと目でわかります。
ブランチを使うメリット
main を安全に保てる：本番環境にすぐ影響しない
複数人での作業がしやすい：機能ごとにブランチを分けられる
変更の管理がしやすい：何を変更したかが明確になる

ブランチを切る方法
1. 新しいブランチを作成する
このチュートリアルでは、Gitにおける「新しいブランチを作成する（＝ブランチを切る）」操作について学びます。
ブランチを活用することで、コードの変更を本番環境に影響させずに進めることができ、チーム開発でも非常に重要な役割を果たします。
Gitのブランチは、「作業中のスナップショットを分けて管理する」ための仕組みです。
この記事では、新しいブランチの作成とその切り替えまでを実際に手を動かしながら学んでいきましょう。
前提条件
Git がインストールされている
GitHub にリポジトリを作成済み
すでにリポジトリをローカルに clone している（または git init 済み）
ブランチとは？
ブランチとは、今のコードをベースに別の開発ラインを作る仕組みです。
例えば、新しい機能を試したい時、バグ修正をしたい時にブランチを使うことで、main（メインのコード）を壊さずに作業ができます。
よく使われるブランチ名：feature/ とは？
feature/〇〇 という形式のブランチ名は、「新しい機能（feature）を追加するための作業ブランチ」を意味します。
たとえば、ログイン画面を作る場合は feature/login-ui という名前でブランチを作ると、何の作業をするブランチかがひと目でわかります。
ブランチを使うメリット
main を安全に保てる：本番環境にすぐ影響しない
複数人での作業がしやすい：機能ごとにブランチを分けられる
変更の管理がしやすい：何を変更したかが明確になる
実施手順
1. 現在のブランチを確認する
まずは今どのブランチにいるかを確認してみましょう。
terminal.sh
git branch
出力結果
* main
※
が付いているのが現在のブランチです。
2. 新しいブランチを作成する
ここでは feature/login-ui という名前のブランチを作ってみましょう。
terminal.sh
git branch feature/login-ui
3. 作成したブランチに切り替える
ブランチを作成しただけでは切り替わっていません。
切り替えるには checkout を使います。
terminal.sh
git checkout feature/login-ui
出力結果
Switched to branch 'feature/login-ui'
※ Git のバージョンが 2.23 以降の場合、switch コマンドでもOKです。
terminal.sh
git switch feature/login-ui
4. 作成と同時に切り替えたい場合
1つのコマンドで作成と切り替えをしたい場合は -b オプションを使います。
terminal.sh
git checkout -b feature/login-ui
または
terminal.sh
git switch -c feature/login-ui
出力結果
Switched to a new branch 'feature/login-ui'
補足
ブランチ名には / を使ってディレクトリ風に分類するのが一般的です（例：feature/〇〇, bugfix/〇〇）。
ブランチ名はわかりやすく具体的にすると、後から見返したときに何をしていたかが理解しやすくなります。


Fast-forwardマージとは、現在のブランチの先頭が、マージ対象のブランチの先頭に追いついていないだけのときに、履歴をそのまま前に進めるマージ方法です。
つまり、分岐が起きていないシンプルな開発フローで使われることが多く、マージコミットが発生しないのが特徴です。
マージコミットとは？
一方で、**マージコミット（merge commit）**は、複数のブランチで開発が並行して進み、分岐していた履歴を1つに統合するときに自動で作られる特別なコミットです。
このとき、コミット履歴に「Merge branch 'feature/〜'」のようなメッセージが追加されます。

プルリクエストとは？
プルリクエスト（Pull Request）とは、「自分が作業したブランチの変更を、mainなどの他のブランチに取り込んでもらうように依頼する仕組み」のことです。
GitHubでは、UIを使ってこのプルリクエストを簡単に作成・確認できます。
チームでのコードレビューや変更履歴の確認にも活用されます。
実施手順
1. GitHub 上でリポジトリを開く
まず、対象となる GitHub リポジトリのページにアクセスします。

画面上部にある [Pull requests] タブをクリックしましょう。
2. [New pull request] をクリック
[Pull requests] タブの右側にある [New pull request] ボタンをクリックします。
3. 比較するブランチを選ぶ
次に、比較対象のブランチを選択します。
base → main（変更を取り込む側）
compare → feature/hello-update など（変更を加えたブランチ）
正しく設定すると、差分（変更内容）が下に表示されます。
4. タイトルと説明を記入して作成
変更内容に問題がなければ、以下を入力します。
タイトル：簡潔に変更の概要を記述（例：hello.txt を更新）
説明：どんな変更を行ったか、なぜその変更が必要なのかを簡単に記載
入力後、[Create pull request] ボタンをクリックしましょう。
5. プルリクエストの確認とマージ
プルリクエストを作成すると、レビュー用の画面が表示されます。
内容を確認し、マージして問題なければ、画面下の [Merge pull request] ボタンをクリックします。
その後、[Confirm merge] を押すとマージが完了します。
出力結果
Pull request successfully merged and closed
✅ これで、変更内容が main ブランチに統合されました。
補足
レビュー依頼：チームで開発している場合は、プルリクエスト作成後にレビュワーを指定できます。
マージ方法の選択：デフォルトではマージコミットされますが、Squash や Rebase も選択できます。
Draft（下書き）として作成することで、レビュー前に保留にしておくことも可能です。


マージコンフリクトが起きた場合は、対象ファイルを編集してから git add → git commit でマージを完了します。
--no-ff オプションを付けると、Fast-forward でもマージコミットを強制的に作成できます。


マージ（merge）
git merge は、あるブランチの変更を現在のブランチに取り込むためのコマンドです。
複数の履歴をそのまま残しながら統合するため、ブランチ構造が複雑でも履歴が保たれます。
ターミナル.sh
git switch main
git merge feature/login
このように実行すると、feature/login の変更が main に統合され、必要に応じて「マージコミット」が生成されます。
リベース（rebase）
git rebase は、現在のブランチの変更を、別のブランチの最新の履歴の上に 「付け替える」 コマンドです。
履歴を直線的に整えるため、後から見たときに「どんな変更を順に行ったか」が分かりやすくなります。
ターミナル.sh
git switch feature/login
git rebase main
この操作により、feature/login ブランチの変更が main の最新状態の後ろに再配置されます。
マージとリベースの違い
比較項目
マージ（merge）
リベース（rebase）
履歴の形
分岐をそのまま残す
直線的に整える
履歴の見やすさ
複雑になりやすいが元の形が保たれる
シンプルで読みやすい
コンフリクト解消
1回で済む
複数回発生する可能性あり
利用シーン
チームでの共同作業、公開リポジトリ
個人開発、履歴整理、未公開のブランチの整理におすすめ
どちらを使えばいいの？
チーム作業中・GitHubに公開するブランチ → マージ（履歴を壊さないため）
ローカルで自分の履歴を整理する場合 → リベース（履歴をきれいに整えるため）

git rebase は 履歴を書き換えるので、すでに共有されたブランチでは使わない方が無難です。
rebase の前には git fetch を使って最新のリモート状態を取り込んでから行うのが推奨されます。


これが コンフリクト（衝突） です。
よくある発生パターン
複数のブランチで同じファイル・同じ行を編集した場合
ファイルの一方が削除され、もう一方が編集されていた場合
複数のコミットをrebaseした際に順番が変わってしまい、意図しない状態になった場合
ここでは最もシンプルな「同じ行を編集した」パターンで体験してみましょう。

. コンフリクトが発生したファイルの中身を見る
greet.txt を開くと、以下のような どちらを採用すべきかGitが判断できない状態になっています。
greet.txt.txt
<<<<<<< HEAD
やっほー
=======
Hello
>>>>>>> feature/english
この状態では、まだマージは完了していません。
補足
<<<<<<<, =======, >>>>>>> の記号は Gitがどこが衝突しているかを示す記号です。
ファイルを修正しないまま git commit しようとすると、Gitは警告してマージを止めてくれます。

Gitが「自動では解決できません」と伝えてきた状態を、自分の判断で調整し、解決に導くのが開発者の役割です。

<<<<<<< HEAD
（現在のブランチの内容）
=======
（マージ先のブランチの内容）
>>>>>>> feature/english


Hello
💡ポイント
Gitの記号（<<<<<<<, =======, >>>>>>>）は すべて削除する必要があります。  
この記号が残っていると、Gitは「解決していない」と判断します。
3. 解決したことをGitに伝える（git add）
修正が終わったら、Gitに「このファイルは解決したよ」と伝えるためにステージします。
ターミナル.sh
git add greet.txt
4. マージを完了させる
次に、マージ処理を完了させます。
ターミナル.sh
git commit
このとき、デフォルトでマージコミット用のメッセージが用意されているので、特に変更しなくてもそのまま保存すればOKです。
または以下のようにメッセージ付きで実行することもできます：
ターミナル.sh
git commit -m "コンフリクトを解消してマージ完了"
出力結果
出力結果
[main abc1234] コンフリクトを解消してマージ完了
補足
VS Code などのエディタでは、コンフリクト箇所を自動的にハイライトしてくれたり、 [受け入れる] ボタンで選択できたりします。
コマンドラインでも git status を使えば、どのファイルが未解決かを確認できます。


git rebase -i）」の使い方を学びます。
過去のコミットを きれいに整理したり、メッセージを修正したり、不要な履歴をまとめたり するのにとても便利なコマンドです。

git rebase -i は、過去の複数のコミットに対して「まとめる（squash）」「順番を入れ替える（reorder）」「メッセージを直す（reword）」などの編集を対話形式で行える強力なツールです。
履歴を整理することで、以下のようなメリットがあります。
Pull Request のレビューがしやすくなる
不要なコミットがなくなり、履歴が読みやすくなる
チーム開発で「綺麗な履歴を保つ」文化に役立つ

インタラクティブリベースは 共有前の履歴整理 に向いています（GitHubへPushする前に行うのが理想）。
リモートにPush済みのブランチに対してリベースすると履歴が書き換わるため、 強制Pushが必要になる点に注意しましょう。
コード例.sh
git push -f


1. チーム開発で困ること
このレッスンでは、チーム開発においてよく起こるトラブルや課題について学びます。
「なぜブランチ運用が大事なのか？」を理解するための土台として、具体的な困りごとを通して考えてみましょう。
よくある悩みとは？
チーム開発では、次のような課題がよく発生します。
他の人の修正とぶつかる
どのファイルが正しいのかわからなくなる
いつの間にか本番に壊れたコードが入っていた
レビューがないままコードがマージされた
これらの問題は、コードの「共有」や「管理」がうまくできていないことが原因です。
具体例：1ファイルを同時に編集して起きること
たとえば、次のような状況を想像してみましょう。
Aさん：
に新しいバナーを追加
Bさん：同じ
で文字サイズの調整を実施
それぞれがローカルで編集し、そのままGitHubにpushしてしまうと、Gitのコンフリクト（競合）が発生し、どちらかの変更が失われる可能性があります。
こういった「ぶつかり」を防ぐには、誰が・いつ・何を編集したかを把握しやすいルール作りが必要です。
チーム開発で起きがちなトラブルまとめ
困ること
原因
よくある失敗
修正が上書きされる
同じファイルを別々に変更
コンフリクトが多発し対応に時間がかかる
バグが本番に混入
レビューなしでmainへ直接マージ
テスト不足・動作確認漏れ
誰が何をしたかわからない
ブランチ名やコミットメッセージが不明確
トラブル調査に時間がかかる
なぜブランチ運用が必要なのか？
こうした問題を解決するために、「ブランチ運用（開発の流れのルール）」を整えることがとても重要です。
ブランチを使えば
各人の作業を分離して進められる
安全に変更内容をレビュー・確認できる
問題が起きたときにどの変更が原因か追いやすい


GitHub Flowは、GitHubを使ったシンプルで実践的な開発の流れです。

特に、Webサービス開発やアジャイル開発の現場で広く使われています。
基本の流れは以下の6ステップです。
main ブランチは常に本番にリリースできる状態にしておく
機能開発や修正は新しいブランチ（例：feature/add-login）で行う
作業が完了したら GitHub にプッシュする
Pull Request（PR）を作成して、変更内容を共有する
他のメンバーがコードレビューを行う
問題がなければ main にマージしてデプロイ
このように、1つの変更に対して1つのブランチを作るという考え方が基本です。
なぜGitHub Flowが使われるの？
特徴
メリット
シンプルなルール
初心者でも理解しやすく導入しやすい
小さな変更単位で管理
問題発生時にすぐ原因を特定できる
自動テスト・レビューと相性が良い
品質を保ちやすい
ブランチごとに機能や修正を分離
作業の見通しが立てやすい・管理しやすい
GitHub Flow の流れ（図解）
mainブランチ新しいブランチ作成
feature/login開発作業GitHubにPushPull Request作成コードレビューmainにマージ
このように、mainは常に安定した状態を保ち、変更内容は別のブランチで安全に進めます。

ブランチ名の命名ルールをチームで統一すると混乱を防げます（例：feature/〜, bugfix/〜など）
Pull Requestには目的や背景を書くとレビューしやすいです


こうした問題を防ぐために、ブランチの使い方をチームで統一することが重要です。
GitHubではこれを 「ブランチ保護ルール（Protect Branch）」や「必須レビュー」 といった機能で実現できます。
よく使われるブランチルールの例
ルール名
内容
目的
mainへの直接Pushを禁止
PR経由でのみマージ可能にする
安定性の確保
必須レビューの設定
PRは1人以上の承認が必要
ダブルチェックによる品質向上
マージの制限（Squash Merge推奨など）
履歴をスッキリ保つ
読みやすい履歴管理
CIチェックの必須化
テストが通らないPRはマージ不可
バグの混入防止
実施手順
ここでは、GitHubで実際に「mainブランチを保護し、レビュー必須ルールを設定する方法」を紹介します。


実施手順
ここでは、GitHubで実際に「mainブランチを保護し、レビュー必須ルールを設定する方法」を紹介します。
1. リポジトリの [Settings] を開く
GitHubの対象リポジトリにアクセスし、上部メニューから [Settings] をクリックします。
※「Settings」タブは管理権限を持つユーザーのみ表示されます。
2. 左メニューの [Branches] を選ぶ
画面左のメニューから [Branches] を選択します。
3. [Add branch protection rule] をクリック
[Branch protection rules] セクションにある [Add rule] ボタンをクリックします。
4. ルール内容を設定する
以下のように設定してみましょう。
Branch name pattern: main
✅ Require a pull request before merging
✅ Require approvals（最低1件）
✅ Dismiss stale pull request approvals
✅ Require status checks to pass before merging（CIを使っている場合）
設定が終わったら [Create] ボタンをクリックして完了です。
出力結果（見た目の変化）
保護ルールを設定したあと、main ブランチには直接Pushできなくなります。
出力結果
$ git push origin main
To github.com:example/repo.git
 ! [remote rejected] main -> main (protected branch hook declined)
このようにエラーになります。必ずPull Requestを経由する必要があります。
補足
Squashマージを推奨すると、履歴が1つのコミットにまとまり、あとで読みやすくなります。
ルールを厳しくしすぎると開発スピードが落ちることも。チームの規模やスキルに合わせて調整しましょう。


Pull Requestの流れ（全体像）
作業用ブランチを作る（例：feature/add-title）
作業を行い、コミット＆Push
GitHub上でPRを作成
レビュー依頼 → 承認
mainにマージ（Squash Merge推奨）



タグの種類
特徴
軽量タグ
単なる参照。コミットに名前をつけるだけ
注釈付きタグ
作者名・作成日・メッセージなどのメタ情報付き
それぞれの目的や用途に応じて、正しく使い分けることが大切です。
軽量タグと注釈付きタグの違い
軽量タグ（lightweight tag）
git tag v1.0.0 のように、単に現在のコミットに名前をつける
メタ情報なし（作成者・日時・コメントなど記録されない）
個人のメモ用途や簡易的なチェックポイントに向いている
注釈付きタグ（annotated tag）
git tag -a v1.0.0 -m "初回リリース" のように作成
作成者・日付・メッセージなどのメタ情報を保持
一般的なバージョン管理やリリース時に推奨される

タグの一覧確認
git tag


出力結果
v0.1.0
v1.0.0

タグの詳細情報一覧
git show v1.0.0

タグはリモートに push されません。明示的に git push origin <tag> で送信が必要です。
タグの削除は git tag -d <tag名> で行えます。
GitHubのRelease画面と連携させたい場合は annotatedタグが推奨です


Semantic Versioning（セマンティックバージョニング）とは？
セマンティックバージョニング（略してSemVer）は、バージョン番号に意味を持たせて「何がどれだけ変わったのか」を表現するルールです。
バージョンは、次の形式で構成されます。
MAJOR.MINOR.PATCH

それぞれの意味は次の通りです。
番号
意味
MAJOR
後方互換性のない変更があったときに更新
MINOR
機能追加など後方互換性がある変更があったときに更新
PATCH
バグ修正など小さな修正のときに更新
例：
1.2.0 → 1.3.0（新機能を追加した）
1.3.0 → 2.0.0（APIの仕様を大きく変えた）
セマンティックなバージョニングに従うことで、ユーザーが「このバージョンは安全に更新できるか？」を判断しやすくなります。
Conventional Commits とは？
Conventional Commits（慣例的なコミット）とは、コミットメッセージの書き方を一定のルールに従って統一する方法です。
これにより、変更の種類や影響度が一目で分かるようになり、自動的にバージョン管理やリリースノートの生成がしやすくなります。
基本構文
<type>(<optional scope>): <説明文>

よく使われるtype
type
意味
feat
新機能の追加
fix
バグ修正
docs
ドキュメントのみの変更
styleう
フォーマット修正など
refactor
挙動を変えないコードの改善
test
テスト関連の追加・修正
chore
ビルド・CI設定など雑務系
例：
feat: ユーザープロフィール画面を追加  
fix(login): ログイン時のリダイレクト不具合を修正  
docs(readme): セットアップ手順を追記


GitHub Releaseとは？
GitHub Release は、リポジトリの中で公式な「リリース」としてタグを管理できる機能です。
以下のような目的で使われます。
チームやユーザーへのリリース内容の通知
アプリのビルド成果物（zip, tar.gz等）の添付
Semantic Versioning に基づく変更履歴の管理
タグがあるだけでは「バージョン番号の記録」ですが、GitHub Releaseを使うことで「誰にとってもわかりやすいリリース情報」にできます。

実施手順
1. GitHubのリポジトリページにアクセスする
まずは GitHub 上の対象リポジトリにアクセスしましょう。
その上で、画面上部の [Releases] タブ、または [Tags] タブをクリックしてください。
2. 新しいリリースを作成する
[Draft a new release] ボタンをクリックして、リリース作成画面に進みます。
Tag version：既存のタグ（例：v1.0.0）を選択します。まだない場合はここで新規作成も可能です。
Release title：わかりやすいタイトルを入力します（例：初回リリース）
3. リリースノートを入力する
Describe this release というエリアに、今回のリリース内容を記載します。
よくある構成：
🚀 概要（目的、背景）
✨ 追加機能（Features）
🐛 バグ修正（Bug Fixes）
📝 備考（Known Issues など）
Markdown 記法に対応しているので、見出しやリストも使えます。
release_note.md
## 🚀 初回リリース

### ✨ 追加機能
- ログイン/ログアウト機能の実装
- TODOの追加・編集・削除機能

### 🐛 バグ修正
- ログイン画面の表示崩れを修正
4. 必要であればビルド成果物を添付する
もし .zip や .tar.gz などのビルド成果物があれば、画面下部にファイルをドラッグ＆ドロップで追加できます。
5. 公開する
[Publish release] ボタンをクリックすれば、リリース情報が GitHub 上に公開されます！
出力結果
リリース v1.0.0 が公開されました 🎉
補足
リリース内容はあとから編集できます。
「Draft（下書き）」として保存することも可能です。
GitHub Actions を使えば、リリース作成時に自動ビルド・デプロイすることもできます。


git stash で変更を避難
作業中の変更をコミットする前に、ちょっと他のブランチで作業したいときや、間違えて main ブランチで直接修正してしまったときなど、いったん変更を保存して退避させたい場面はよくあります。
そんなときに便利なのが git stash です。

git stash は、作業中の変更を一時的に退避させる Git のコマンドです。
退避した変更はあとで戻すことができるので、安心して作業を中断できます。
こんな場面で使えます。
作業中に急遽別のブランチに移動したいとき
今の作業をいったん保留して、他の修正をしたいとき

避難
git stash

復元
git stash apply

変更されたファイルが複数ある場合も、git stash でまとめて退避されます。
git stash -u で未追跡ファイルも一緒に保存
未追跡ファイル（git add していないファイル）は通常退避されませんが、以下のようにすると一緒に退避可能です：
unstaged.sh
git stash -u


1. スタッシュの一覧を確認する
git stash list を使うと、保存されたすべてのスタッシュが表示されます。

2. スタッシュを復元（適用）する
スタッシュを復元するには git stash apply を使います。

最新のスタッシュを適用したい場合は、引数なしで実行できます。
apply-latest.sh
git stash apply
特定のスタッシュを指定して適用したいときは、stash@{n} の形式で指定します。
apply-specific.sh
git stash apply stash@{1}
出力結果
On branch main
Changes not staged for commit:
  (use "git add ,[object Object]
3. スタッシュを削除する（1件）
適用が終わったスタッシュは、git stash drop で削除できます。
drop.sh
git stash drop stash@{0}
出力結果
Dropped stash@{0} (abc1234 Update readme)
4. スタッシュをすべて削除する（まとめて消す）
使い終わったスタッシュを一括で削除したいときは、git stash clear を使います。
clear.sh
git stash clear
出力結果
（出力なし、成功時は静かに終了）
補足
git stash apply は「適用のみ」で、スタッシュそのものは残ります。
→ 削除したい場合は明示的に drop しましょう。
git stash pop は適用後にスタッシュを自動で削除します。
→ 一括でやりたいときに便利です（ただし適用に失敗した場合は注意）。


3. ビルド生成物の削除 (git clean)
開発をしていると、node_modules/ や dist/ などのビルド生成物がローカルに溜まっていきます。
これらは Git の管理対象外のファイルですが、不要になったら一括で削除したくなる場面もありますよね。
このレッスンでは、Git の git clean コマンドを使って、作業ディレクトリをすっきりクリーンアップする方法を学びましょう。
前提条件
Git がインストールされていること
.gitignore によって管理対象外ファイルが存在していること（例：node_modules/）
git clean とは？
git clean は、Git 管理下にないファイルやディレクトリを削除するためのコマンドです。
特に以下のようなケースで便利です。
ビルド生成物（例：dist/）を削除したい
node_modules やキャッシュファイルを一掃したい
クリーンな状態で再ビルドやデバッグを行いたい
※ git clean は削除対象のファイルを 完全に削除します。必要なファイルを誤って削除しないよう注意が必要です。
実施手順
1. 現在の状態を確認する
まずは、Git がどのようなファイルを管理対象外として認識しているかを確認してみましょう。
status.sh
git status
出力結果
Untracked files:
  (use "git add ,[object Object]
ここに表示されているファイルが、git clean の削除対象になります。
2. 削除対象をプレビューする（安全確認）
git clean をいきなり実行するのではなく、まずは -n オプションで「何が削除されるか」を確認しましょう。
dry-run.sh
git clean -nd
出力結果
Would remove dist/
Would remove node_modules/
この出力により、削除対象を事前に確認できます。
3. 実際にファイルを削除する
問題なければ -f（force）と -d（ディレクトリ対象）を付けて実行します。
clean.sh
git clean -fd
出力結果
Removing dist/
Removing node_modules/
これで、管理対象外のビルド生成物が一括で削除されました。
補足
-n オプションは プレビューのみ を行うので、まずはこちらで確認する習慣をつけましょう。
-x オプションを使うと .gitignore に記載されたファイルも削除されるため、注意して使う必要があります。
with-x.sh
git clean -fdx
このコマンドは強力なので、通常は使わずに済むよう .gitignore を整備しておくのが理想です。


commit --amend とは？
git commit --amend は、直前のコミットを修正するためのコマンドです。
以下のようなケースでよく使われます。
コミットメッセージを直したい
ステージし忘れたファイルを追加したい
ただし、すでに共有されたコミットを書き換えると他の人に影響を与える可能性があるため、基本的にはpush前のローカル作業時のみ使うようにしましょう。

付け替え
git commit --amend -m "Initial commit"

ファイルの追加忘れ修正
--no-edit は、コミットメッセージをそのまま使いたいときに指定します。
echo "export const sum = (a, b) => a + b;" > utils.js
git add utils.js
git commit --amend --no-edit
小さなミスは誰にでもあります。慌てず --amend を活用して、きれいな履歴を作っていきましょう。

git rebase -i とは？
git rebase -i は、過去の複数コミットを対話的（interactive）に編集するコマンドです。
主に以下のような場面で使われます。
コミットを1つにまとめたい（squash）
コミットメッセージを修正したい（reword）
一部のコミットを削除したい（drop）
順番を入れ替えたい（reorder）
これにより、より読みやすくきれいな履歴を作ることができます。

強制プッシュ（--force）とは？
Gitでは、リモートブランチよりも古い履歴を push しようとすると、通常の git push は拒否されます。
これは「他の人の履歴を壊すかもしれない」というGitの安全装置です。
しかし、git rebase などで履歴を書き換えた後には、リモートとの差異が出るため、強制的に上書きする --force オプションを使う必要があります。
例：通常の push が失敗するパターン
rebase.sh
git push
出力結果
! [rejected]        main -> main (non-fast-forward)
error: failed to push some refs
hint: Updates were rejected because the tip of your current branch is behind
このように、リモートの履歴と一致しない場合は push が拒否されます。
実施手順
1. rebase や amend を使って履歴を変更する
前回のチュートリアルなどでコミットの履歴を書き換えた状態を用意してください。
rebase-edit.sh
git rebase -i HEAD~2
# 例：コミットをsquashしたりメッセージを修正
2. 通常の push が失敗することを確認する
push.sh
git push
リモートの履歴とずれている場合、push は拒否されます。
3. --force で強制的にpushする
force.sh
git push --force
これでローカルの履歴がリモートに反映されます。
出力結果
Enumerating objects: 5, done.
Counting objects: 100% (5/5), done.
Writing objects: 100% (3/3), 420 bytes | 420.00 KiB/s, done.
To github.com:yourname/repo.git
 + abc1234...def5678 main -> main (forced update)
補足
--force-with-lease のおすすめ
単純な --force は他人のコミットも消してしまう危険があります。

そこで、安全な強制push として --force-with-lease の使用をおすすめします。
safe-force.sh
git push --force-with-lease
これは「リモートにあるはずの履歴が変わっていなければ上書きしてよい」という条件つきで動作します。
チームでの注意点
チーム開発では 保護されたブランチ（protected branch） に対して --force はできないよう設定するのが一般的です。
基本的に main や develop などの共有ブランチでは --force は使わず、個人の feature ブランチでのみ使用しましょう。

