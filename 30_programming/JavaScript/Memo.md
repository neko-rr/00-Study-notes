# 基礎知識
## ECMAScript（エクマスクリプト）
- Javascriptの標準規格
- 1年に1回発表される
- ES6=ES2015（昔の呼び名＝現在普及させたい呼び名）
- ES2015が転換点で重要
## トランスパイラ
- ES2015で開発して、古いのに変換してくれる
## SPA
- モダンJavascriptは、SPAが基本
### SPAメリット
- ページ遷移毎のチラつき（一瞬真っ白）が無くなる
- 表示速度アップによるユーザー体験向上
- コンポーネントへの分割が簡単になる開発向上
## モジュールバンドラ
- 複数のjsファイル（CSS/image）を1つにまとめたもの
- 開発時は、ファイル分割して作成。本番時は1つにまとめて、早く実行
## npm/yarn（エヌピーエム/ヤーン）
- node_modules
  - 各モジュールの実態
  - サイズが膨大のため、GitHubには上げないように注意

# 変数名等の付け方
- 数字開始は、エラーが出る
- 非推奨：日本語名・ローマ字
## booleanブーリアン
true falseは、小文字
## キャメル ケースがJavaScriptでは一般的
途中の文字:大文字
## 最初の文字も大文字はパスカル ケース
## アンダースコア使用は、スネーク ケース
## Booleanだと最初にisの変数使用の場合が多い

# 基本
文の最後はセミコロン（;）で終わります。セミコロンはなくても正常に動作する場合が多いですが、思わぬ不具合が生じる可能性があるので忘れずに付ける
# 指定した情報を画面に表示する関数：console.log()
実行確認のため
```JavaScript
console.log('ここに表示したい内容');
```
# コメント
JavaScriptでは、//を使って1行コメントを記述し、/*と*/で囲むことで複数行コメントを記述します。
```JavaScript
// これは1行コメントです

/*
  これは複数行コメントです
  複数行にわたってコメントを書けます
*/
```
# 文字列
文字列はシングルクォート'またはダブルクォート"で囲んで記述します。
# 数値：number
- 数値を記述する際は、（シングルクォート (') やダブルクォート (") は使わず、そのまま数字を入力します。
- 数値の型は、1種類のみ
# 変数・定数：let・var・const(コンスト)
変数は、後で値を変更できる情報の入れ物で、定数は一度決めた値を変更しない情報の入れ物です。JavaScriptでは、変数を定義するためにletやvarを使い、定数を定義するためにconstを使います。
```JavaScript
let 変数名 = 値;
var 変数名 = 値;
const 定数名 = 値;
```
- let後から値が変更できる変数を定義します。（再代入可能）
- varは古い方法で、基本的にはletやconstを使うことが推奨されます。
  - 理由：再宣言可能のため、意図せず上書きしまくっていた
- const後から値の変更できない変数を定義します。（再代入不可能）
- ※変数・定数をconsole.logで出力する際には、シングルクォート(')やダブルクォート(")は 不要 です
## 変数の更新
- 定義する時と違って「let」は必要ない
- プログラムは上から順に実行されるので、後で代入された値で変数の中身が更新される
```JavaScript
変数名 = 新しい値;
```
## 変数の更新：数字
- 「number += 1」は「number ++」のように省略して書くことができる
- 「number -= 1」を「number --」も同様
# 文字列連結
加算演算子+を文字列に用いると、文字同士の連結
- +を使った結合の、片方の値が文字列で、もう片方が文字列でない場合には、文字列でない値が文字列に自動変換された上で文字列連結されます。
# テンプレートリテラル
変数・定数、数値、式を埋め込むこんだ文字列を作成する方法。文字列結合の手間を省くことができます。テンプレートリテラルはバッククォート (``) を使って文字列全体を囲み、${}で変数や式を記述することで、値を文字列に埋め込むことができます。
- ES6から？
```JavaScript
`文字列 ${変数名}`
```
```JavaScript
let a = 5;
let b = 10;
let result = `計算結果は${a + b}です`;
console.log(result);
```
# null
nullは、JavaScriptで「何もない」ことを示す値です。変数に何も値が設定されていないことを示したいときに使います。値を初期化するときによく使われます。
# undefined
undefinedは、変数を作ったがまだ値を入れていないときに使われます。変数を作った後に何も値を代入しないと、その変数の値はundefinedになります。
# 等価演算子：==
異なる型の値を比較し、「同じ値」であるかを判断するために使います。
```JavaScript
const value = 1 == '1';
console.log(value);
```
true
| 演算子 | 説明 |
|--------|-----|
| == | 左辺と右辺が「同じ値」である |
| != | 左辺と右辺が「同じ値」ではない |
## 型変換のルール
- 数値と文字列の比較: 文字列が数値に変換され、数値同士で比較されます。
- 真偽値との比較: 真偽値（trueやfalse）は、数値に変換され、trueは1、falseは0になります。
- オブジェクトとの比較: オブジェクトは、プリミティブ値に変換され（通常はtoStringやvalueOfメソッドを使用）、その結果が比較されます。
# 厳密等価演算子：===
2つの値が同じ型であり、かつ同じ値であるかを確認するための演算子
| 演算子 | 説明 |
|--------|-----|
| === | 左辺と右辺が「同じ値」かつ「同じ型」である |
| !== | 左辺と右辺が「同じ値」ではないか「同じ型」ではない |
## 等価演算子（==）と厳密等価演算子（===）の違い
等価演算子（==）は、値を比較する際に型を自動的に変換します。一方、厳密等価演算子（===）は、値だけでなく型も比較します。つまり、==は型が異なっても同じ値と見なすことがありますが、===は型が異なると必ず異なると判断します。
```JavaScript
console.log(5 == '5');  // true（型変換あり）
console.log(5 === '5'); // false（型変換なし）
```
# 比較演算子
| 演算子 | 説明 |
|--------|-----|
| == | 等価 |
| === | 厳密な等価（値の型まで比較）|
| != | 不等価 |
| !== | 厳密な不等価（値の型まで比較）|
| < | 小なり（左辺の値が右辺の値より小さいこととを判定） |
| >	| 大なり（左辺の値が右辺の値より大きいことを判定） |
|<=	| 小なりイコール（左辺の値が右辺の値以下であることを判定） |
|>=	| 大なりイコール（左辺の値が右辺の値以上であることを判定） |
# 論理積：&&
複数の条件がすべて真（true）であるときにのみ真を返す演算子
```JavaScript
条件1 && 条件2
```
- 最初の値が偽である場合
  - &&は最初に偽があるとそこで評価を止める
```JavaScript
const value = true && 'false' && 5;
console.log(value);
```
全て真値なので最後の5が出力されます。'false'は文字列であり真値とみなされます。
# 論理和：||
左から右に順番に値を見ていき、最初に見つけた真（true）とされる値を返します。もし全てが偽（false）とされる場合は、最後の値を返します。
```JavaScript
条件1 || 条件2
```
- 真と評価される値
  - 任意のゼロでない数値（1、-1、100など）
  - 空でない文字列（"hello"、'world'など）
  - 空でないオブジェクト（{}、[]を含む）
- 偽と評価される値
  - false：論理的な偽
  - 0：数値のゼロ
  - ""または''：空の文字列
  - null：何もない、空の値
  - undefined：値が未定義
  - NaN：数値ではない（Not a Number）
# 論理否定：!
ある条件が「真」であるか「偽」であるかを反転させたいときに使います。具体的には、真（true）を偽（false）に、偽（false）を真（true）に変換します。
```JavaScript
!条件
```
```JavaScript
console.log(!true);
console.log(!false);
```
false  
true
```JavaScript
console.log(!'hoge');
console.log(!undefined);
```
false  
true
# 条件分岐：if
- 最後のセミコロン不要
- 見やすさのため、if文を書くときは、インデントをするようにする
- if文の条件がfalseの場合、elseの処理が実行される
- ifとelseの間に「else if (条件)」を追加することで、if文に条件分岐を追加することができる
```JavaScript
if (条件式1) {
  条件式1がtrueの場合に実行されるコード
}else if (条件式2){
  条件式1がfalseの場合に実行されるコード＆条件式2がtrueの場合に実行されるコード
}else{
  全ての条件がfalseの場合に実行されるコード
}
```
# 条件分岐：switch
- ある値によって処理を分岐する場合にswitch文
- caseを使用して、複数分岐可能
- break;までの処理を実行。break無いと、複数caseがbreakある所まで全部実行される
- defaultがあると、どのcaseに当てはまらなかった場合に実行される
- 最後のセミコロン不要
```JavaScript
switch(条件の値){
  case 値1:
    条件の値が値1と等しい時の処理
    break;
  case 値2:
    条件の値が値2と等しい時の処理
    break;
  default:
    全ての条件に当てはまらない場合に実行されるコード
    break;
}
```
# 繰り返し：while
- 「条件式がtrueの間、{ }内の処理を繰り返す」ことができる
- **値の更新コード忘れると、｢無限ループ｣になる**
- 最後のセミコロン不要
```JavaScript
while (条件式){
  処理
  変数の更新必須
}
```
# 繰り返し：for
- whileよりもシンプルに書ける
```JavaScript
for (変数の定義; 条件式; 変数の更新){
  処理
}
```
## 繰り返しの条件付き：forとifの組み合わせ
```JavaScript
for (変数の定義; 条件式; 変数の更新){
  if (条件式1) {
    条件式1がtrueの場合に実行されるコード
  }else if (条件式2){
    条件式1がfalseの場合に実行されるコード＆条件式2がtrueの場合に実行されるコード
  }else{
    全ての条件がfalseの場合に実行されるコード
  }
}
```
# 配列
- 配列に入っているそれぞれの値のことを要素と呼ぶ
  - 配列の要素にはそれぞれインデックス番号が0からついている
- 配列も1つの値なので、定数に代入することができる
  - 配列を代入する定数名は、慣習上複数形にすることが多い
```JavaScript
[値1, 値2, 値3]
```
配列[インデックス番号]とすることで配列の要素を取得することができる
```JavaScript
const 定数名= [値1, 値2, 値3];
console.log(定数名[0]);
```
出力：値1
## 配列の更新
一度定義した定数には、配列自体を再度代入することはできませんが、配列の要素を更新することはできます
```JavaScript
const 定数名= [値1, 値2, 値3];
定数名[0] = 値4
```
出力：[値4, 値2, 値3]
## 配列の取り出し：for
- 配列の変数.lengthで、配列の数が分かる
- 変数の値は0から始めることに注意
```JavaScript
for (let i = 0; i < 配列の変数.length; i++){
  処理iを用いて、色々する「配列の変数[i]」
}
```
例：「配列の変数」の値が「undefined」と等しいかどうかで処理を分岐
## オブジェクトを要素に持つ配列（逆も可能）
- コードが横に長くなることを防ぐために、要素ごとに改行することがよくある
- 配列の中のオブジェクトのプロパティの値を取り出すには、「配列[インデックス番号].プロパティ名」
# オブジェクト
- 配列は複数の値を並べて管理するのに対して、オブジェクトはそれぞれの値にプロパティと呼ばれる名前をつけて管理
- オブジェクトも定数に代入することができる
```JavaScript
{プロパティ名1:値1, プロパティ名2:値2, プロパティ名3:値3}
```
オブジェクトの値を取り出すには、対応するプロパティ名を用いて、「オブジェクト.プロパティ名」のようにします
```JavaScript
const 定数名 = {プロパティ名1:値1, プロパティ名2:値2, プロパティ名3:値3}
console.log(定数名.プロパティ名1);
```
出力：値1
## オブジェクトの更新
「オブジェクト.プロパティ名 = 新しい値」とすることでオブジェクトの値を更新することができる
# 関数
- いくつかの処理をまとめたもの
- 関数宣言の特徴は、コード順番に関係なく実行されます
```JavaScript
function 関数名 (仮引数1, 仮引数2) {実行処理}
```
例：引数に渡された数値を2倍する関数doubleを宣言より先に呼び出す
```JavaScript
double( 5 ) // 実行結果:  10
function double(num){  console.log( num * 2) }
// 関数宣言のため、エラーとならず呼び出せる
```
# アロー関数
- 関数式をより短く記述できる構文。省略形がある。
- アロー関数は、functionキーワードを使わずに関数を定義し、=>を使って関数の処理を記述
```JavaScript
// アロー関数の基本構文
const 関数名 = (引数1, 引数2, ...) => {
  // 関数の処理
};
```
例1: 引数に個数と単価を渡し金額を計算するアロー関数を定義する
```JavaScript
const payment = (count, price) => {  return count * price };
```
例2: 引数が1つの場合()を省略できる。追加：処理が1文の場合、returnも省略できる
```JavaScript
const double = count => count * 2;
```
例3: 引数に1を足して、コンソールに出力
```JavaScript
const onePlusCount = (val) => {
  val++;
  console.log(val);
};
onePlusCount(0);
onePlusCount(10);
```
1  
11
- よくあるエラーは{}で囲ったら、「return」必須
- ({関数が複数行})という使い方も良く出てくる
## デフォルト値
関数の引数のデフォルト値・分割代入
```JavaScript
const sayHallo(neme = "ゲスト") => console.log(`こんにちは！${name}さん`)
```
## オブジェクトの省略記号注意
- 設定するプロパティと変数が同じならば省略可能
- 特に1行だと分からない
# 分割代入
## オブジェクトの分割代入
オブジェクトを分割（分解）し、プロパティを取り出して、個別の変数に代入すること
```JavaScript
const myFavoriteAnimal = {
  name: 'たま',
  type: 'cat'
}

// オブジェクトの分割代入
const { name, type} = myFavoriteAnimal

// 分割代入を使用した結果
console.log(name) // 'たま'
console.log(type) // 'cat'
```
## 配列の分割代入
変数定義の右辺に配列を、左辺に配列の値を代入したい変数名を書きます。
基本的に、右辺の配列の要素は、左辺の対応するインデックスをもつ変数に代入されます。
```JavaScript
// 配列の定義
const myFavoriteAnimal = ['たま', 'cat']

// 配列の分割代入
const [name, type] = myFavoriteAnimal

// 分割代入を使用した結果
console.log(name) // 'たま'
console.log(type) // 'cat'
```
インデックスの途中までしか必要ない場合は、以降の要素を省略できます。
配列のインデックス（index）とは、配列の要素の順番を指します。
配列の先頭の要素を0番目とし、要素が増えるごとにインデックスも1,2,3,..。と増えていきます。
```JavaScript
// 1つ目のみ必要な場合は以下のように指定できます。
const [name] = myFavoriteAnimal
console.log(name) // 'たま'
```
# スプレッド構文
# 配列の各要素をチェックして条件に合うものだけを新しい配列として返す:filter
配列の各要素をチェックして条件に合うものだけを新しい配列として返す
```JavaScript
console.log([1, 2, 3, 4, 5, '1'].filter((number) => number !== '1'));
```
[1, 2, 3, 4, 5]
# 三項演算子
- if...elseの省略版のようなもの
- 条件に当てはまるかどうかを判定して、条件式が真（true）の時はコロンの前の値 、偽（false）の時はコロンの後の値を返す
```JavaScript
条件 ? 真の場合の値 : 偽の場合の値
```
```JavaScript
let age = 10;

// IF文
if (age >= 20) {
  console.log('私は20歳以上です');
} else {
  console.log('私は20歳未満です');
}
// 三項演算子
console.log(age >= 20 ? '私は20歳以上です' : '私は20歳未満です');
```
私は20歳未満です


# 未整理
# スプレッド構文
配列やオブジェクトの要素を一つずつ取り出して、1つ1つ別々のものとして扱うことができます。これは、配列やオブジェクトを簡単にコピーしたり、要素を追加したりする場合に非常に便利
- 例：「...配列」で、配列がそのまま出力される
- 例：まとめる（配列設定で一部は複数まとめるとか）
  - 配列のコピーや結合がしやすい
正例
```JavaScript
const arr1 = [5, 10];
const arr2 = [...arr1];
arr2[0] = 100;
console.log(arr1);
```
悪例
```JavaScript
const arr1 = [5, 10];
const arr2 = arr1;
arr2[0] = 100;
console.log(arr1);
```
出力arr1も2も100に変わってしまう（同じ場所参照しているので）
正例：オブジェクトに要素を追加して新しいオブジェクトを作成
```JavaScript
const user = { id: 1, age: 20 }
const updatedUser = {
  ...user,
  job: 'teacher'
}

console.log(updatedUser) // { id: 1, age: 20, job: 'teacher' }
```
# 仮想DOM
- Document Object Model（ドキュメントオブジェクトモデル）の略
- HTMLやXMLでマークアップされた文書を、JavaScriptなどのスクリプトからアクセス・操作できるようにするAPI（アプリケーションプログラミングインターフェース）
- HTMLなどを木構造で表現したもの
- これまでは、DOMを直接操作していた
  - レンダリングコスト高、コード複雑化
- 仮想DOMを噛ます事で、変更差分のみをDOMに反映させる



# .map
呼び出し元の配列の各要素に対して処理を行い、元の配列を変更せずに新しい配列を作成
- ループ（forの代わり）に使用可能
```JavaScript
let 新しい配列 = array.map((element, index, array) => {
  // 処理
  return element;
});
```
- element: 現在処理中の要素
- index: 現在処理中の要素のインデックス（省略可能）
- array: 元の配列（省略可能）
```JavaScript
const users = [
  { name: 'Smith' },
  { name: 'Johnson' },
  { name: 'Williams' },
  { name: 'Brown' }
];
console.log(users.map((user) => 'Mr. ' + user.name));
```
['Mr. Smith', 'Mr. Johnson', 'Mr. Williams', 'Mr. Brown']

## forEachメソッドとの違い
forEachメソッドは各要素に処理を実行するだけであるのに対して、 mapメソッドは新しい配列を返します。
新しい配列を必要としない場合や値を返す必要がない場合は、forEachメソッドを使用
```JavaScript
const arr = [1,2,3];

const forEachValue = arr.forEach(value => {
  return value * 100;
})
console.log(forEachValue);

const mapEachValue = arr.map(value => {
  return value * 100;
})
console.log(mapEachValue);
```
出力
undefined
[100, 200, 300]

# .filter

