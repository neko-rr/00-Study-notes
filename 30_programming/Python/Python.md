# 基本
# データや文字列を画面に出力：print
```Python
print(値)
```
##  テキスト
ダブルクォーテーション（"）またはシングルクォーテーション（'）で囲まれたテキストは文字列として認識されます。どちらを使用しても問題ありませんが、プログラムの中で統一して書くようにしてください。
- 一貫性: プログラム内でどちらか一方を選び、統一して使うことが大切です。
- エスケープ: 文字列内に同じ種類のクォーテーションが含まれる場合、もう一方を使うか、エスケープ（\）する必要があります。
  - 例: print("It's a sunny day!") または print('He said, "Hello!"')
```Python
print(出力する文字列 "Hello, World!")
print(出力する文字列 'Hello, World!')
```
## 複数の値の出力
print関数では、カンマ,を使って複数の値を同時に出力することができます。
これにより、異なるデータタイプの値を一度に出力することが可能です。
```Python
name = "Alice"
age = 25
print(name, "さんは", age, "歳です。")
```
Alice さんは 25 歳です。
## 区切り文字と改行の制御
printでは、出力する要素の区切り文字や末尾の改行を制御できます。
```Python
print("Hello", "world", sep="-", end="!")
print("I love you")
```
Hello-world!I love you
## 使用可能なデータ型
文字列（str）、整数（int）、浮動小数点数（float）、リスト（list）、タプル（tuple）、辞書（dict）、ブール値（bool）など
# コメント
## 1行
```Python
# これはコメントです
print("Hello, World!") # この後ろもコメントです
```
## 複数行
```Python
"""
これは複数行の
コメントです。
プログラムの実行には影響しません。
"""

'''
これも複数行の
コメントです。
プログラムの実行には影響しません。
'''
print("Hello, World!")
```
複数行の文字列としての使用する
```Python
message = """
これは複数行の
文字列です。
プログラムの実行に影響します。
"""
print(message)
```
# 変数
変数名 = 値
```Python
number1 = 5
print(number1)
```
- 変数名の頭文字を数字にするのは、不可
- 「user_name」のように2語以上の変数名を使うときは、単語と単語の間を _ (アンダーバー)で区切る
- 日本語も設定できてしまうが、辞めた方が良い
## 変数の更新
```Python
variable = 100
variable = "Hello, World!"
print(variable)
```
Hello, World!
# 型変換
- 数値型を文字列型に変換するには「str」
- 文字列型を数値型に変換したい場合には「int」
# 論理演算
```Python
# 論理演算の基本構文
条件1 and 条件2
条件1 or 条件2
not 条件
```
- 「and」を用いて複数の条件式を組み合わせると、全ての条件式がTrueの場合に全体がTrue
- 比較を連結してandの条件を下記のように続けて書くことも可能
- notは条件が真 (True) の場合に偽 (False) になり、偽 (False) の場合に真 (True) になります。
- notを使った条件の反転は、特定の条件が満たされていない場合に処理を行いたいときに役立ちます。例えば、ユーザーがログインしていない場合にのみ「ログインしてください」と表示する時などです。条件を反転させることで、簡潔に意図を表現できます。
# 演算
同じ意味
```Python
X = X + 10
X += 10
```
# 比較演算
```Python
a == b  # aとbが等しいかどうかを確認
a != b  # aとbが等しくないかどうかを確認
a > b   # aがbより大きいかどうかを確認
a < b   # aがbより小さいかどうかを確認
a >= b  # aがb以上かどうかを確認
a <= b  # aがb以下かどうかを確認
```
比較演算子を使う際は、特にデータ型に注意が必要です。異なる型（例えば、数値と文字列）を比較すると、意図しない結果になることがあります。また、==と!=は値の比較ですが、isはオブジェクトの同一性を確認します。これを混同しないようにしましょう。正確な比較を行うために、データ型を確認してから使用することが大切です。
## 文字列の比較
文字列が同じかどうかを確認する場合に使用します。
例えば、ユーザーが入力したパスワードが正しいかどうかを確認することができます。
```Python
correct_password = "password123"
user_input = "password123"

print(user_input == correct_password)  # True
```
Pythonでは、文字列の比較は大文字と小文字を区別します。例えば、"abc"と"ABC"は異なる文字列と見なされ、比較結果はFalseになります。大文字と小文字を無視して比較したい場合は、両方の文字列を小文字または大文字に変換してから比較します。例えば、user_input.lower() == correct_password.lower()のように使います。
# if
```Python
if 条件:
  条件が真の場合に実行されるコード
else:
  条件が偽の場合に実行されるコード
```
```Python
number = 5

if number > 10:
  print("この数は10より大きいです")
else:
  print("この数は10以下です")
```
この数は10以下です
- ifの後に条件を記述し、その条件が真の場合に実行するコードをインデントして書く
  - インデントが無いと、IF文の外として扱われる
- elseはifの条件が偽の場合に実行するコードをインデントして書きます。
```Python
if 条件1:
  実行するコード1
elif 条件2:
  実行するコード2
```
```Python
score = 85

if score >= 90:
  print("優秀")
elif score >= 70:
  print("良好")
elif score >= 50:
  print("普通")
else:
  print("要改善")
```
良好
- 上から順に条件が成り立つか判断され、最初に条件に合致した部分の処理だけが行われます
- また、elifは複数使えますが、無駄に多く使うとコードが読みにくくなるので、必要な条件だけを設定することが大切です。最後に、elseを使って全ての条件に該当しない場合の処理を追加することも考慮しましょう。
# if/ネスト
ネストは、if文の中にさらに別のif文を入れることで、複数の条件を組み合わせて複雑な判断を行うことができます。
```Python
if 条件1:
  # 条件1が真のときの処理
  if 条件2:
    # 条件1と条件2が両方真のときの処理
```
- ifは「もし〜ならば」を意味し、条件が真（True）のときにその下のインデントされたコードが実行されます。
- ネストされたif文は、外側のif文の条件が真である場合にのみ評価されます。
```Python
score = 95

if score >= 60:
  print("合格です。")
  if score >= 90:
    print("優秀です。")
```
変数scoreが60以上なので「合格です。」がまず表示されます。
さらにif score >= 90ではscoreが90以上なので真（True）となり、「優秀です。」も表示されます。
## 戻り値
- 「True」にあたるのが戻り値です。「return 戻り値」と書くことで戻り値を呼び出し元に返すことができます
- 条件式でTrue == TrueまたはFalse == Trueを比較する場合は== Trueを省略することができます
- returnは戻り値を呼び出し元に返すだけでなく、関数内の処理を終了させる性質も持っています。よって、return以降の関数の処理が実行されることはありません
## 処理の途中終了：break
if文などと組み合わせて利用します
```Python
numbers = [765, 921, 777, 256]
for number in numbers:
    print(number)
    # 変数 number が 777 のとき「 777が見つかったので処理を終了します 」と出力した後、処理を終了させてください
    if number == 777:
        print("777が見つかったので処理を終了します")
        break
```
## その周だけ処理をスキップ：continue
if文などと組み合わせて利用します
```Python
numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
for number in numbers:
    # 変数 number の値が 3 の倍数のとき、繰り返し処理をスキップしてください
    if number % 3 == 0:
        continue
    print(number)
```
# 複数のデータをまとめて管理：リスト
- 複数の文字列や複数の数値を1つのものとして管理することができる
- 変数に代入可能。リストを代入する変数名は慣習上複数形にすることが多い
```Python
[要素1, 要素2, ...]
```
インデックス番号：前から順に「0, 1, 2,・・・」
```Python
リスト[インデックス番号]
```
##  リストの更新
```Python
リスト[インデックス番号] = 値
```
##  リストの追加
```Python
リスト.append(値)
```
# 辞書
- 個々の要素をインデックス番号ではなくキーと呼ばれる名前を付けて管理する
- ほとんどの場合、キーには文字列が使われます
- 辞書を出力してみると、要素の順番が定義したときと変わっています。このように辞書内の要素には順序がないことに気をつけましょう。
  - **Python 3.7以降はキーの順序を保証するようになりました。**
```Python
{キー1: 値1, キー2: 値2, …}
```
辞書の値を取り出すには、取り出したい値に対応する「キー」を用いて辞書名[キー]
```Python
fruits = {'apple': 'りんご', 'banana': 'バナナ', 'grape': 'ぶどう'}

# for 文を用いて、辞書のキーを1つずつ取り出し、繰り返しの中で「 ◯◯は△△という意味です 」と出力させてください
for fruit_key in fruits:
    print( fruit_key+ "は" + fruits[fruit_key] + "という意味です")
```
## 辞書の更新
```Python
辞書名[キー名] = 値
```
## 辞書の追加
辞書にすでにあるキー名を指定すると、値の追加ではなく更新になってしまうので注意
```Python
辞書名[新しいキー名] = 値
```
# 繰り返し：for
変数には、リストの要素が先頭から順に1つずつ入っていき、その上でfor文の中の処理が実行されます。処理はリストの要素の数だけ繰り返し行われます（繰り返し処理）。
また、変数名は自由ですが、リスト名の単数形にすることが慣習上多い
```Python
for 変数名 in リスト:
    繰り返し処理内容
```
# 繰り返し：while
ある条件に当てはまる間、処理を繰り返す
- while文内の処理が一周終わると、その度に変数は更新され、再び条件式がチェックされます。Trueであればもう一周処理を行い、Falseであれば繰り返しを終了します
- **while文では処理の最後に変数の値を更新し忘れると、条件が常にTrueになってしまうので、繰り返し処理が無限に行われてしまいます（無限ループ）**。無限ループはコンピュータに異常な負荷をかけることになるので、確実に阻止しなければなりません。繰り返し処理では、必ずどこかで条件がFalseになるように実装しましょう。
- **変数の値を更新する処理を記述する際にインデントを忘れるとwhile文の外と見なされてしまいます**。よって、while文の条件式が永遠にTrueになるので無限ループとなる
```Python
while 条件式:
    繰り返し処理内容
```
# 関数:def
```Python
def 関数名():
    実行する処理内容
```
出力
- 関数は定義した後でしか呼び出せない
```Python
関数名()
```
## 仮引数
- 関数の定義部分で、引数を受け取るための箱となる変数（仮引数（かりひきすう））
  - 関数が複数の引数を受け取るためには、仮引数をコンマ（,）で区切って定義
  - 引数は左から順番に「第1引数、第2引数・・・」
  - 初期値の設定可能「def 関数名(仮引数 = 初期値）:」
- 変数には、その変数が使える範囲が存在します。その範囲のことをスコープと呼びます。
  - 仮引数や関数の中で定義した変数のスコープは関数の中だけ
  - エラー：NameError
```Python
def 関数名(仮引数):
    実行する処理内容
```
出力
```Python
関数名(引数)
```
# モジュール
別のファイルに関数を分けて読み込む
モジュールを読み込んで使いたいファイルに、「import モジュール名」と書くことで読み込むことができます。
モジュール名はファイル名から拡張子（.py）を取り除いたものとなります
「モジュール名.関数名()」と書くことで、モジュール内の関数を実行することができます。
引数がある場合、関数を使用するときと同様に()のなかに書きます。
# クラスの定義
設計図のことをクラス、「もの」のことをインスタンス
- step1：クラスを用意する
- step2：インスタンスの生成
- step3：インスタンスに情報を追加する
## step1：「クラスを用意する」
- クラス名は「MenuItem」のように大文字で始める
- 処理：「pass」＝これは何も処理がないことを表す
```Python
class クラス名:
    処理
```
## step2：インスタンスの生成
クラス（設計図）を用いて新しくインスタンスを生成する
```Python
クラス名()
```
生成したインスタンスを変数に代入する
```Python
変数名 = クラス名()
```
## step3：インスタンスに情報を追加する
インスタンス（メニュー）には、自由に様々な情報を追加することが可能
```Python
menu_item1.name = 'サンドイッチ'
```
「name」のことを「インスタンス変数」と呼ぶ

使用方法
```Python
インスタンス.インスタンス変数名
```
## メソッド
- クラスの中で定義した関数のことをメソッドと呼ぶ
- メソッドの定義の方法は通常の関数と同じですが、第1引数にselfを追加する必要がある
```Python
class クラス名:
    def 関数名(self,第2引数...):
        実行する処理内容
インスタンス = インスタンス内容()
```
クラスの中で定義したメソッドは、インスタンスに対して使うように呼び出します
```Python
インスタンス.メソッド名()
```
- クラスの中で定義し、インスタンスに対して呼び出すメソッドのことを、「インスタンスメソッド」と呼ぶ
- インスタンスメソッドの第1引数に指定した「self」には、そのメソッドを呼び出したインスタンス自身が代入されている
  - メソッド内で「self.name」とすることで、そのメソッドを呼び出している「menu_item1」の「name」の値を取得することができます
## 戻り値：return
使用可能
## 特殊インスタンスメソッド：__init__
- 「クラス名()」でインスタンスを生成した直後に自動で呼び出される
- 他のインスタンスメソッドと同じように定義することができる
- インスタンスを生成すると同時にインスタンス変数に値を代入することができる
  - step2・3を同時にできる
  - 実行する処理内容部分で、「self.変数名 = 値」でインスタンス変数に値を代入できる
- __init__メソッドは通常のインスタンスメソッドと同じように、引数を受け取ることもできます
```Python
class クラス名:
    def __init__(self,第2引数...):
        実行する処理内容
インスタンス = インスタンス内容(必要ならば引数)
```
自動で__init__の内容が実行される


